/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jturunen <jturunen@student.hive.fi>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/12/17 13:44:04 by jturunen          #+#    #+#             */
/*   Updated: 2022/01/20 08:55:20 by jturunen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"
#include "libft.h"

static int	new_line_present(char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (0);
	while (str[i])
	{
		if (str[i] == '\n')
			return (1);
		i++;
	}
	return (0);
}

static char	*get_next(char *str)
{
	int		i;
	char	*next_line;

	i = 0;
	if (!str)
		return (0);
	while (str[i] && str[i] != '\n')
		i++;
	next_line = malloc(sizeof(char) * (i + 1));
	if (!next_line)
		return (0);
	i = 0;
	while (str[i] && str[i] != '\n')
	{
		next_line[i] = str[i];
		i++;
	}
	next_line[i] = '\0';
	return (next_line);
}

static char	*save_next(char *saved_line)
{
	char	*next_save;
	int		i;
	int		j;

	i = 0;
	j = 0;
	if (!saved_line)
		return (0);
	while (saved_line[i] && saved_line[i] != '\n')
		i++;
	if (!saved_line[i])
	{
		free(saved_line);
		return (0);
	}
	next_save = malloc(sizeof(char) * ((ft_strlen(saved_line) - i) + 1));
	if (!next_save)
		return (0);
	i++;
	while (saved_line[i])
		next_save[j++] = saved_line[i++];
	next_save[j] = '\0';
	free(saved_line);
	return (next_save);
}

int	get_next_line(const int fd, char **line)
{
	static char	*saved_line;
	char		*buffer;
	int			reading;

	reading = 1;
	if (fd < 0 || !line || BUFF_SIZE <= 0)
		return (-1);
	buffer = malloc(sizeof(char) * (BUFF_SIZE + 1));
	if (!buffer)
		return (-1);
	while (!new_line_present(saved_line) && reading != 0)
	{
		reading = read(fd, buffer, BUFF_SIZE);
		if (reading == -1)
		{
			free(buffer);
			return (-1);
		}
		buffer[reading] = '\0';
		saved_line = ft_strjoin(saved_line, buffer);
	}
	free(buffer);
	*line = get_next(saved_line);
	saved_line = save_next(saved_line);
	if (reading == 0)
		return (0);
	return (1);
}

/* woops
function that returns a line read from a file descriptor
line is a succession of characters that end with '\n' (ascii 0x0a) or with EOF

must be prototyped as:
int	get_next_line(const int fd, char **line);

first parameter is the filedescriptor that will be used to read
second parameter is the address of a pointer to a character that will be used
to save the line read from the FD

return value can be 1, 0 or -1, has been read, when the reading has been
completed, or if error occured respectively

function has to return its result WITHOUT '\n'!!!

calling your function in a loop will then allow you to read the text available
on a FD one line at a time until end of the text, no matter the size of either
the text or one of its lines.

make sure that your function behaves well when it reads from a file,
standard output, redirection etc.

in header file you must have at least the prototype of the function,
macro that allows to choose the size of the reading buffer for the read funct.
This value will be modded during defence, IT MUST BE NAMED as BUFF_SIZE
For example: #define BUFF_SIZE 32

make sure to test it with different buff_size:s like 9999, 1, 1000000 etc

we consider that get_next_line function has undefined behaviour if,
between two calls, the same FD designs two distinct files although the reading
from the first file was not completed.

we consider also taht a call to lseek(2) will never take place between two calls
 of the function on the same FD

Finally we consider that get_next_line has an undefined behaviour when reading 
from a binary file. However you can make this behaviour coherent.

Global variables are forbidden.

Static variables are allowed.

BONUS

Get it working with single static variable

To be able to manage multiple file descriptor with your get_next_line
for example, if the FD 3, 4, and 5 are accessible for reading, then you can call
get_next_line once on 3,once on 4, once again on 3 then once on 5 etc.
without losing the readin thread on each of the FD.
*/
